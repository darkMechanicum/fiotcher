package com.tsarev.fiotcher.dflt

import com.tsarev.fiotcher.api.FiotcherException
import com.tsarev.fiotcher.api.KClassTypedKey
import com.tsarev.fiotcher.api.PoolIsStopped
import com.tsarev.fiotcher.api.Stoppable
import com.tsarev.fiotcher.dflt.flows.Aggregator
import com.tsarev.fiotcher.internal.pool.AggregatorPool
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.Executor

/**
 * Default implementation of [AggregatorPool].
 */
class DefaultAggregatorPool(

    /**
     * Maximum capacity for aggregator queues.
     */
    private val aggregatorMaxCapacity: Int,

    /**
     * Executor, used to perform queue submission and processing by aggregators and trackers.
     */
    private val queueExecutorService: Executor,
    /**
     * Executor, used to perform pool stopping.
     */
    private val stoppingExecutor: Executor,
) : AggregatorPool, Stoppable {

    /**
     * Events, that are generated by trackers, aggregated by keys.
     */
    private val aggregators = ConcurrentHashMap<KClassTypedKey<*>, Aggregator<*>>()

    /**
     * Stop brake.
     */
    private val brake = Brake<Unit>()

    override fun <EventT : Any> getAggregator(key: KClassTypedKey<EventT>): Aggregator<EventT> {
        // Sync on the pool to handle stopping properly.
        synchronized(this) {
            validateIsStopping { PoolIsStopped() }
            val result = aggregators.computeIfAbsent(key) {
                Aggregator<EventT>(queueExecutorService, stoppingExecutor, aggregatorMaxCapacity)
            }
            return result as? Aggregator<EventT> ?: throw FiotcherException("Seems like somehow another type occupied map place.")
        }
    }

    override val isStopped get() = brake.get() != null

    override fun stop(force: Boolean) = brake.push { brakeFuture ->
        val aggregatorsCopy = HashMap(aggregators)
        val allAggregatorsStopFuture = aggregatorsCopy.values
            .map { it.stop(force) }
            .reduce { first, second -> first.thenAcceptBoth(second) { _, _ -> } }

        allAggregatorsStopFuture.thenAccept {
            aggregators.clear()
            brakeFuture.complete(Unit)
        }
    }

    /**
     * Throw exception if pool is stopping.
     */
    private fun validateIsStopping(toThrow: () -> Throwable) {
        if (isStopped) throw toThrow()
    }

}