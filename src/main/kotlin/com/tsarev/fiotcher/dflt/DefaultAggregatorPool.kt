package com.tsarev.fiotcher.dflt

import com.tsarev.fiotcher.api.FiotcherException
import com.tsarev.fiotcher.api.PoolIsStopping
import com.tsarev.fiotcher.api.Stoppable
import com.tsarev.fiotcher.dflt.flows.Aggregator
import com.tsarev.fiotcher.internal.KClassTypedKey
import com.tsarev.fiotcher.internal.pool.AggregatorPool
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.ExecutorService

/**
 * Default implementation of [AggregatorPool].
 */
class DefaultAggregatorPool(

    /**
     * Maximum capacity for aggregator queues.
     */
    private val aggregatorMaxCapacity: Int,

    /**
     * Executor, used to perform queue submission and processing by aggregators and trackers.
     */
    private val queueExecutorService: ExecutorService,
) : AggregatorPool, Stoppable {

    /**
     * Events, that are generated by trackers, aggregated by keys.
     */
    private val aggregators = ConcurrentHashMap<KClassTypedKey<*>, Aggregator<*>>()

    /**
     * Stop brake.
     */
    private val brake = Brake<Unit>()

    override fun <EventT : Any> getAggregator(key: KClassTypedKey<EventT>): Aggregator<EventT> {
        // Sync on the pool to handle stopping properly.
        synchronized(this) {
            checkIsStopping { PoolIsStopping() }
            val result = aggregators.computeIfAbsent(key) {
                Aggregator<EventT>(queueExecutorService, aggregatorMaxCapacity)
            }
            return result as? Aggregator<EventT> ?: throw FiotcherException("Cant be here within normal operation")
        }
    }

    override val isStopped get() = brake.get() != null

    override fun stop(force: Boolean) = brake.push { brakeFuture ->
        val aggregatorsCopy = HashMap(aggregators)
        val allAggregatorsStopFuture = aggregatorsCopy.values
            .map { it.stop(force) }
            .reduce { first, second -> first.thenAcceptBoth(second) { _, _ -> } }

        allAggregatorsStopFuture.thenAccept {
            aggregators.clear()
            brakeFuture.complete(Unit)
        }
    }

    /**
     * Throw exception if pool is stopping.
     */
    private fun checkIsStopping(toThrow: () -> Throwable) {
        if (isStopped) throw toThrow()
    }

}