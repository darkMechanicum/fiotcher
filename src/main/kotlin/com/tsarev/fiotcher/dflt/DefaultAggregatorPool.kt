package com.tsarev.fiotcher.dflt

import com.tsarev.fiotcher.api.PoolIsStopping
import com.tsarev.fiotcher.api.Stoppable
import com.tsarev.fiotcher.api.tracker.AggregatorPool
import com.tsarev.fiotcher.api.tracker.TrackerEventBunch
import com.tsarev.fiotcher.dflt.flows.Aggregator
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.ExecutorService

/**
 * Default implementation of [AggregatorPool].
 */
class DefaultAggregatorPool<WatchT : Any>(

    /**
     * Maximum capacity for aggregator queues.
     */
    private val aggregatorMaxCapacity: Int,

    /**
     * Executor, used to perform queue submission and processing by aggregators and trackers.
     */
    private val queueExecutorService: ExecutorService,
) : AggregatorPool<WatchT>, Stoppable {

    /**
     * Events, that are generated by trackers, aggregated by keys.
     */
    private val aggregators = ConcurrentHashMap<String, Aggregator<TrackerEventBunch<WatchT>>>()

    /**
     * Stop brake.
     */
    private val brake = Brake<Unit>()

    /**
     * Create new aggregator at need.
     */
    override fun getAggregator(key: String): Aggregator<TrackerEventBunch<WatchT>> {
        // Sync on the pool to handle stopping properly.
        synchronized(this) {
            checkIsStopping { PoolIsStopping() }
            return aggregators.computeIfAbsent(key) {
                Aggregator(queueExecutorService, aggregatorMaxCapacity)
            }
        }
    }

    override val isStopped get() = brake.get() != null

    override fun stop(force: Boolean) = brake.push { brakeFuture ->
        val aggregatorsCopy = HashMap(aggregators)
        val allAggregatorsStopFuture = aggregatorsCopy.values
            .map { it.stop(force) }
            .reduce { first, second -> first.thenAcceptBoth(second) { _, _ -> } }

        allAggregatorsStopFuture.thenAccept {
            aggregators.clear()
            brakeFuture.complete(Unit)
        }
    }

    /**
     * Throw exception if pool is stopping.
     */
    private fun checkIsStopping(toThrow: () -> Throwable) {
        if (isStopped) throw toThrow()
    }

}